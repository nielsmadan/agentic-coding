#!/bin/bash

# Required for Raycast Script Commands
# @raycast.schemaVersion 1
# @raycast.title Next Claude Session
# @raycast.mode silent
# @raycast.icon ðŸ¤–

PRIMARY_QUEUE="$HOME/.claude_session_queue"
COMPLETED_QUEUE="$HOME/.claude_completed_queue"
SCRIPT_DIR="$HOME/.claude/hooks"

# Get python3 path
PYTHON3_PATH="$(command -v python3)"
if command -v pyenv &> /dev/null; then
    PYTHON3_PATH="$(pyenv which python3 2>/dev/null || echo "$PYTHON3_PATH")"
fi

SESSION_ID=""
QUEUE_TYPE=""

# Get currently focused session (if any)
CURRENT_SESSION=""
if [ -n "$PYTHON3_PATH" ]; then
    # Try to get current session, capture it if check returns success
    CURRENT_SESSION=$("$PYTHON3_PATH" -c "
import iterm2
import sys
async def main(connection):
    app = await iterm2.async_get_app(connection)
    window = app.current_terminal_window
    if window and window.current_tab:
        session = window.current_tab.current_session
        if session:
            print(session.session_id)
            return
    sys.exit(1)
try:
    iterm2.run_until_complete(main)
except:
    sys.exit(1)
" 2>/dev/null)
fi

# First check primary queue (sessions waiting for input - highest priority)
if [ -f "$PRIMARY_QUEUE" ] && [ -s "$PRIMARY_QUEUE" ]; then
    # Get first session that isn't the currently focused one
    while IFS= read -r line; do
        if [ -n "$line" ] && [ "$line" != "$CURRENT_SESSION" ]; then
            SESSION_ID="$line"
            break
        fi
    done < "$PRIMARY_QUEUE"

    if [ -n "$SESSION_ID" ]; then
        QUEUE_TYPE="primary"
    fi
fi

# Then check completed queue (most recent first, so read from end)
if [ -z "$SESSION_ID" ] && [ -f "$COMPLETED_QUEUE" ] && [ -s "$COMPLETED_QUEUE" ]; then
    # Read from end, skip current session
    while IFS= read -r line; do
        if [ -n "$line" ] && [ "$line" != "$CURRENT_SESSION" ]; then
            SESSION_ID="$line"
            # Don't break - we want the last non-current one
        fi
    done < "$COMPLETED_QUEUE"

    if [ -n "$SESSION_ID" ]; then
        QUEUE_TYPE="completed"
    fi
fi

if [ -z "$SESSION_ID" ]; then
    echo "No sessions waiting"
    exit 0
fi

if [ -z "$PYTHON3_PATH" ]; then
    echo "Python3 not found"
    exit 1
fi

# Handle queue updates
if [ "$QUEUE_TYPE" = "primary" ]; then
    # Rotate: move selected session to end (cycle through)
    grep -vxF "$SESSION_ID" "$PRIMARY_QUEUE" > "$PRIMARY_QUEUE.tmp"
    echo "$SESSION_ID" >> "$PRIMARY_QUEUE.tmp"
    mv "$PRIMARY_QUEUE.tmp" "$PRIMARY_QUEUE"
else
    # Remove selected session from completed queue
    grep -vxF "$SESSION_ID" "$COMPLETED_QUEUE" > "$COMPLETED_QUEUE.tmp" && mv "$COMPLETED_QUEUE.tmp" "$COMPLETED_QUEUE"
fi

# Activate the session
"$PYTHON3_PATH" "$SCRIPT_DIR/activate_iterm_session.py" "$SESSION_ID"

# Count remaining in both queues
primary_count=0
completed_count=0
[ -f "$PRIMARY_QUEUE" ] && primary_count=$(wc -l < "$PRIMARY_QUEUE" 2>/dev/null | tr -d ' ')
[ -f "$COMPLETED_QUEUE" ] && completed_count=$(wc -l < "$COMPLETED_QUEUE" 2>/dev/null | tr -d ' ')

if [ "$primary_count" -gt 0 ]; then
    echo "$primary_count waiting for input"
elif [ "$completed_count" -gt 0 ]; then
    echo "$completed_count completed"
else
    echo "Queue empty"
fi
